[
{
	"uri": "https://arcman7.github.io/en/tags/algorithm/",
	"title": "algorithm",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/",
	"title": "ARC",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/k-means/",
	"title": "k-means",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/k_means_clustering/",
	"title": "K-Means Clustering",
	"tags": ["python", "k-means", "machine learning", "algorithm"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "In this post we will implement the K-Means Clustering algorithm in python. You will not need to know any python libraries such as numpy or pandas as this will be done in vanilla python. The key take aways here are:\n The algorithm by itself is naive, and not guaranteed to converge on the best fit centroid locations We need an optimizer of sorts to find an acceptable centroid fit  The goal of the K-means clustering algorithm is to fit a given set of data points into K specified groups or clusters. For example, say we have the following xy-coordinate data:\n .control { display: flex; flex-direction: column; justify-content: center; align-items: center; } #demo-1 { display: flex; width: 100%; height: 500px; justify-content: center; } #demo-1-controls { margin-top: 5px; margin-bottom: 15px; display: flex; width: 100%; justify-content: center; }     K-Clusters  N points per cluster  Cluster spread    // generate data: function getRandomArbitrary(min, max) { return Math.random() * (max - min) + min; } function getLinearData(n_points = 20, m = 2, b = 7, variance = 3) { const y_train = []; const x_train = []; for (let x = 0; x { const td = document.createElement('td'); td.innerText = data[key] + (i === 0 ? ',' : ''); tr.appendChild(td); }); return tr; } function getTable(data = [['X', 'Y'], [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) { const table = document.createElement('table'); // table.style = 'overflow-y: scroll; max-height: 500px'; Object.keys(data).forEach((key) = { table.appendChild(getRow(data[key])) }); return table } function setFakeDataInDom(data, id) { const container = document.getElementById(id); container.innerHTML = ''; data.unshift(['X', 'Y']); container.appendChild(getTable(data)); } function getFakeData() { const kEle = document.getElementById('k-clusters'); const k = Number(kEle.value || 5) || 5; const nEle = document.getElementById('n-data-points'); const n_points = Number(nEle.value || 10) || 10; const spreadEle = document.getElementById('s-spread'); const spread = Number(spreadEle.value || 10) || 10; const data = getKCluserData(k, spread, n_points); return data; } // svg graph: function getGraphBrackGround(width, height) { const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.classList.add('background-canvas'); rect.setAttribute('x', 0); rect.setAttribute('y', 0); rect.setAttribute('width', width); rect.setAttribute('height', height); rect.setAttribute('fill', '#FFFFFF'); rect.setAttribute('stroke','none'); rect.setAttribute('stroke-width', 0); rect.setAttribute('viewBox', `0 0 ${500} ${500}`); return rect; //  } function getBoldAxis(x1, y1, x2, y2) { const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); g.classList.add('bold-axis'); const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline'); polyline.setAttribute('points', `${x1,y1} ${x1,y2} ${x2, y2}`); polyline.setAttribute('fill', 'none'); polyline.setAttribute('shape-rendering', 'crispEdges'); polyline.setAttribute('stroke', '#444'); polyline.setAttribute('stroke-width', 1); g.appendChild(polyline); return g; /*   */ } function getGridLine(x1, y1, x2, y2) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', x1); line.setAttribute('x2', x2); line.setAttribute('y1', y1); line.setAttribute('y2', y2); line.setAttribute('fill', 'none'); line.setAttribute('shape-rendering', 'crispEdges'); line.setAttribute('stroke', '#ccc'); line.setAttribute('stroke-dasharray', \"5,2\"); line.setAttribute('stroke-width', 1); return line; // vertical //  // horizontal //  } function getGrid(width = 500, height = 500, marginX = 53, marginY = 32) { const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); g.classList.add('grid'); const yS = marginY; const yE = height - marginY; const xS = marginX; const xE = width - marginX; let spacing = Math.floor((xE - xS) / 10); // vertical lines for (let x = xS - spacing; x a[0] - b[0]); // const xMin = Math.min(sortByX[0][0], 0); const xMin = sortByX[0][0]; const xMax = Math.max(sortByX[sortByX.length - 1][0], 100); const sortByY = data.sort((a, b) = a[1] - b[1]); // const yMin = Math.min(sortByY[0][1], 0); const yMin = sortByY[0][1]; const yMax = Math.max(sortByY[sortByY.length - 1][1], 100); const xScale = xWidth / (xMax - xMin); const yScale = yWidth / (yMax - yMin); const xOffset = xS //- xMin; const yOffset = yS //- yMin; console.log(`xOffset: ${xOffset} yOffset: ${yOffset} xE: ${xE} yE: ${yE} xS: ${xS} yS: ${yS} xMin: ${xMin}`) data.forEach((datum) = { const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); const cx = Math.round((xScale * (datum[0] - xMin)) + xOffset); const cy = Math.round(yE - (yScale * (datum[1] - yMin))); if ((cx  xE) || (cy  yE)|| (cx 0) Initialize The first step in the algorithm is to randomly assign (x,y) coordinates to the values of each of the centroids.\nFrom here on the following sequence is followed until convergence:\n1) For each data point  Determine which centroid location is closest, centroid_closest Add data point to the collection of data points belonging to centroid_closest  2) For each centroid point  Update the centroids (x,y) location by taking the average coordinate values of its collection of data points  This procdedure is guaranteed convergence, where additional iterations of the algorithm does not result in location updates for any of the centroids. However, the resulting fitted centroid locations may not be best suited to to the actual existing clusters of data. This is because the procedure we just defined is highly reliant on the initial positions of centroids defined in step 0.\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/machine-learning/",
	"title": "machine learning",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/python/",
	"title": "python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/game/",
	"title": "game",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/games/",
	"title": "Games",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/games/ice-age/",
	"title": "Ice Age",
	"tags": ["javascript", "vue", "game"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Adventure throughout Azeroth and beyond following the events of the Frozen Throne, utilizing a real-time combat game system.\nPlay here\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/javascript/",
	"title": "javascript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/vue/",
	"title": "vue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/vue-js-game/",
	"title": "Vue.js Game",
	"tags": ["javascript", "vue", "game"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "So I built a game engine in javascript using Vue.js to do the rendering. It\u0026rsquo;s in an in-progress project, and therefore this post is as well.\nPlay here\n"
},
{
	"uri": "https://arcman7.github.io/en/notes/",
	"title": "Notes",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "I just made this blog. If there\u0026rsquo;s anything glaringly obvious that I\u0026rsquo;ve missed and need to or should fix please let me know in the comments below.\nAlso, Hugo is awesome, I used it to create this site.\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/asynchronous/",
	"title": "asynchronous",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/javascript-squential-task-que/",
	"title": "Javascript: Sequential Task Queue",
	"tags": ["javascript", "promises", "asynchronous", "sequential order", "queue"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "I decided to write this post as the result of attempting to find a pattern for executing any number of asynchronous tasks in a specified order with javascript. It came as a surprise to me that this isn\u0026rsquo;t supported out of the box in any modern browers javascript engine.\nAfter googling around for a few minutes I came across this related blog post Decembersoft Inc. which comes close but doesn\u0026rsquo;t yield a working solution. I would reccomend checking it out as it was useful for me, and perhaps may hold some value for you as well. However, I will give you the gist of it here:\n Javascript allows you to chain promises in a serial fashion when the tasks are known beforehand and can be hard coded:   return task1.then(task2).then(task3);\n   This pattern does not allow you to programatically execute an unspecified number of asynchronous operations in a given order\n  Reduce to the rescue:\n   We\u0026rsquo;re going to use the Array.reduce() function to collapse the array of promises into a single promise chain.\n  // Serial return [ task1, task2, task3, ].reduce((promiseChain, currentTask) =\u0026gt; { // Note: promiseChain === initialPromise // on the first time through this function /* TODO */ }, initialPromise); (from the blog post)\n Which then leads to:   const reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(chainResults =\u0026gt; currentTask.then(currentResult =\u0026gt; [ ...chainResults, currentResult ] ) ); } const tasks = getTaskArray(); tasks.reduce(reducer, Promise.resolve([])); Okay cool, this is where you realize that it is their authors aim to collect the RESULTS of the promise chain in a sequential order, but not actually fire them off one after another. If you\u0026rsquo;re not sure or don\u0026rsquo;t believe me try this in your console:\n function getTasks() { const task1 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task1'); resolve() }, 2 * 1000); }); const task2 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task2'); resolve() }, 2 * 1000); }); const task3 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task3'); resolve() }, 2 * 1000); }); return [ task1, task2, task3, ] } var reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(currentTask); } var tasks = getTasks(); tasks.reduce(reducer, Promise.resolve()); All of these pending promises fire off at the same time as they\u0026rsquo;ve already been instantiated. Well shoot, back to square one. Just kidding, this pattern actually get\u0026rsquo;s us 90% of the way there. However, instead of having an array of already existing promises we want to use an array of functions that RETURN the promises we want to fire off. This looks like this:\nfunction getTasks() { const task1 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task1'); resolve() }, 2 * 1000); }); } const task2 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task2'); resolve() }, 2 * 1000); }); } const task3 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task3'); resolve() }, 2 * 1000); }); } return [ task1, task2, task3, ] } var reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(currentTask); } var tasks = getTasks(); tasks.reduce(reducer, Promise.resolve()); There, now you can can execute any arbitrary number of promises one after another. All you need to do in your code is collect an array of references to the functions that create/instantiate/return the promise that is the asynchronous operation you want to perform.\nEDIT: This pattern is not as unique as I initially thought. There are various implementations that already exist out there on the web, heres another one:\nhttps://github.com/BalassaMarton/sequential-task-queue\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/promises/",
	"title": "promises",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/queue/",
	"title": "queue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/sequential-order/",
	"title": "sequential order",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "The Author",
	"content": "The Author My name is Andrew Carpenter. I\u0026rsquo;m a fullstack engineer, living in San Francisco. I\u0026rsquo;ve been working in the bay area for the past four years with a focus on building clean UI\u0026rsquo;s for the end user.\nI recieved my bachelors degree in Physics at the University of Hawaii in 2013 and continued to do research on the mini Time Cube (mTC) experiment before switching to software.\n"
},
{
	"uri": "https://arcman7.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]