[
{
	"uri": "https://arcman7.github.io/en/tags/algorithm/",
	"title": "algorithm",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/",
	"title": "ARC",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/k-means/",
	"title": "k-means",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/k_means_clustering/",
	"title": "K-Means Clustering",
	"tags": ["python", "k-means", "machine learning", "algorithm"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "In this post we will implement the K-Means Clustering algorithm in python. You will not need to know any python libraries such as numpy or pandas as this will be done in vanilla python. The key take aways here are:\n The algorithm by itself is naive, and not guaranteed to converge on the best fit centroid locations We need an optimizer of sorts to find an acceptable centroid fit  The goal of the K-means clustering algorithm is to fit a given set of data points into K specified groups or clusters. For example, say we have the following xy-coordinate data:\n .control { margin-top: 10px; margin-right: 5px; display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 3px; font-weight: bold; height: 20px; } .demo { display: flex; width: 100%; height: 500px; justify-content: center; } .demo-controls { margin-top: 5px; margin-bottom: 35px; display: flex; width: 100%; justify-content: center; margin-left: 75px; }     K-Clusters  N points per cluster  Cluster spread    // generate data: function getRandomArbitrary(min, max) { return Math.random() * (max - min) + min; } function getLinearData(n_points = 20, m = 2, b = 7, variance = 3) { const y_train = []; const x_train = []; for (let x = 0; x { const td = document.createElement('td'); td.innerText = data[key] + (i === 0 ? ',' : ''); tr.appendChild(td); }); return tr; } function getTable(data = [['X', 'Y'], [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) { const table = document.createElement('table'); Object.keys(data).forEach((key) = { if (key === 'centroids') { return; } table.appendChild(getRow(data[key])) }); return table } function setFakeDataInDom(data, id) { const container = document.getElementById(id); container.innerHTML = ''; container.appendChild(getTable([['X', 'Y']].concat(data))); } function getFakeData(kid, nid, sid) { const kEle = document.getElementById(kid); const k = Number(kEle.value); const nEle = document.getElementById(nid); const n_points = Number(nEle.value); const spreadEle = document.getElementById(sid); const spread = Number(spreadEle.value); const data = getKCluserData(k, spread, n_points); return data; } // svg graph: function getGraphBrackGround(width, height) { const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.classList.add('background-canvas'); rect.setAttribute('x', 0); rect.setAttribute('y', 0); rect.setAttribute('width', width); rect.setAttribute('height', height); rect.setAttribute('fill', '#FFFFFF'); rect.setAttribute('stroke','none'); rect.setAttribute('stroke-width', 0); rect.setAttribute('viewBox', `0 0 ${500} ${500}`); return rect; //  } function getBoldAxis(x1, y1, x2, y2) { const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); g.classList.add('bold-axis'); const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline'); polyline.setAttribute('points', `${x1,y1} ${x1,y2} ${x2, y2}`); polyline.setAttribute('fill', 'none'); polyline.setAttribute('shape-rendering', 'crispEdges'); polyline.setAttribute('stroke', '#444'); polyline.setAttribute('stroke-width', 1); g.appendChild(polyline); return g; /*   */ } function getGridLine(x1, y1, x2, y2) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', x1); line.setAttribute('x2', x2); line.setAttribute('y1', y1); line.setAttribute('y2', y2); line.setAttribute('fill', 'none'); line.setAttribute('shape-rendering', 'crispEdges'); line.setAttribute('stroke', '#ccc'); line.setAttribute('stroke-dasharray', \"5,2\"); line.setAttribute('stroke-width', 1); return line; // vertical //  // horizontal //  } function getGrid(width = 500, height = 500, marginX = 32, marginY = 32) { const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); g.classList.add('grid'); const yS = marginY; const yE = height - marginY; const xS = marginX; const xE = width - marginX; let spacing = Math.floor((xE - xS) / 10); // vertical lines for (let x = xS - spacing; x a[0] - b[0]); const xMin = sortByX[0][0]; const xMax = Math.max(sortByX[sortByX.length - 1][0], 100); const sortByY = data.sort((a, b) = a[1] - b[1]); const yMin = sortByY[0][1]; const yMax = Math.max(sortByY[sortByY.length - 1][1], 100); const xScale = xWidth / (xMax - xMin); const yScale = yWidth / (yMax - yMin); const xOffset = xS; const yOffset = yS; // console.log(`xOffset: ${xOffset} yOffset: ${yOffset} xE: ${xE} yE: ${yE} xS: ${xS} yS: ${yS} xMin: ${xMin}`) data.forEach((datum) = { const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); const cx = Math.round((xScale * (datum[0] - xMin)) + xOffset); const cy = Math.round(yE - (yScale * (datum[1] - yMin))); // if ((cx  xE) || (cy  yE)|| (cx 0) Initialize The first step in the algorithm is to randomly assign (x,y) coordinates to the values of each of the centroids.\nFrom here on the following sequence is followed until convergence:\n1) For each data point  Determine which centroid location is closest, centroid_closest Add data point to the collection of data points belonging to centroid_closest  2) For each centroid point  Update the centroids (x,y) location by taking the average coordinate values of its collection of data points  This procdedure is guaranteed convergence, where additional iterations of the algorithm does not result in location updates for any of the centroids. However, the resulting fitted centroid locations may not be best suited to to the actual existing clusters of data. This is because the procedure we just defined is highly reliant on the initial positions of centroids defined in step 0. This procedure is demonstrated in the figure below:\n   K-Clusters  N points per cluster  Cluster spread  Pause    function averageCoords(data) { if (data.length === 0) { return [0, 0]; } let x_avg = 0; let y_avg = 0; data.forEach((coord) = { x_avg += coord[0]; y_avg += coord[1]; }); x_avg = x_avg / data.length; y_avg = y_avg / data.length; return [x_avg, y_avg]; } function distance(a, b) { const xSquared = Math.pow(a[0] - b[0], 2); const ySquared = Math.pow(a[1] - b[1], 2); return xSquared + ySquared; // return Math.pow(xSquared + ySquared, 0.5); } function kMeans(k, data) { // const kCentroids = data.centroids; const kCentroids = getRandomData({ n_points: k }); kCentroids.forEach((datum) = { datum.color = 'red'; }); const buckets = []; const oldCentroidsStore = []; let x; let y; let oldCentroids = kCentroids.concat([]); oldCentroidsStore.push(oldCentroids); let keepGoing = true; let count = 0; while (keepGoing) { // re-initialize empty buckets for each centroid for (let i = 0; i { let best = 0; let minDistance = distance(coord, kCentroids[best]); kCentroids.forEach((centroid, index) = { const currD = distance(coord, centroid); if (currD { kCentroids[index] = averageCoords(bucket); kCentroids[index].color = 'red'; }); let didAnythingChange = false; oldCentroids.forEach((oldCentroid, index) = { const centroid = kCentroids[index]; if (distance(oldCentroid, centroid)) { didAnythingChange = true; } }); oldCentroids = kCentroids.concat([]); if (didAnythingChange) { oldCentroidsStore.push(oldCentroids); } count += 1; keepGoing = didAnythingChange; } console.log('Done! After ', count, ' iterations'); return { kCentroids, oldCentroidsStore }; } let intervalTimer; let displayIteration; function pause() { clearInterval(intervalTimer); } function resume() { intervalTimer = setInterval(displayIteration, 1000); } let isPaused = false; let ele; function execute() { if (isPaused) { ele.innerText = 'Pause'; resume(); } else { pause(); ele.innerText = 'Resume'; } isPaused = !isPaused; } function listenForPauseResume(id) { ele = document.getElementById(id); ele.removeEventListener('click', execute); ele.addEventListener('click', execute); } let demo2Svg; function initDemo2(_, globalData) { const data = globalData || getFakeData('k-clusters-2', 'n-data-points-2', 's-spread-2'); setFakeDataInDom(data, 'table-container-2'); const k = data.centroids.length; const { kCentroids, oldCentroidsStore } = kMeans(k, data); const xS = marginX; // const xE = demo2Svg.width.baseVal.value - marginX; const xE = 500 - marginX; const yS = marginY; // const yE = demo2Svg.height.baseVal.value - marginY; const yE = 500 - marginY; let step = 0; let count = 0; let text; let currCentroids; pause(); displayIteration = function () { step = count % oldCentroidsStore.length; if (text \u0026\u0026 text.parentElement === demo2Svg) { demo2Svg.removeChild(text); } if (currCentroids \u0026\u0026 currCentroids.parentElement === demo2Svg) { demo2Svg.removeChild(currCentroids); } const temp = []; oldCentroidsStore.forEach((oldCentroids, stepIndex) = { oldCentroids.forEach((datum) = { if (stepIndex === step) { datum.color = 'red'; } else { datum.color = 'rgba(1,1,1,0)'; } temp.push(datum); }); }) demo2Svg = gridXYScatterPlot(temp.concat(data), 'graph-container-2'); text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); text.setAttribute('x', ((xE - xS) * 0.5) + xS - 40); text.setAttribute('y', marginY - 5); const txt = document.createTextNode(`iteration: ${step} of ${oldCentroidsStore.length - 1}`); text.appendChild(txt); demo2Svg.appendChild(text); count += 1; }; intervalTimer = setInterval(displayIteration, 1000); } listenForPauseResume('demo-2-pause-resume'); initDemo2(null, window.data); selectElement = document.getElementById('k-clusters-2'); selectElement.addEventListener('change', initDemo2); selectElement = document.getElementById('n-data-points-2'); selectElement.addEventListener('change', initDemo2); selectElement = document.getElementById('s-spread-2'); selectElement.addEventListener('change', initDemo2);  I encourage you to test out varitions with the parameters K-Clusters, N points per cluster and Cluster spread. You will quickly see that the locations of the centroids that the algorithm converges on are quite often far from ideal. Some centroids end up with no points in their cluster group while other centroids end up in the middle between two or more clusters that have been assigned to it.\nThe occurence of miss-fits observed in the above plot makes it quite clear how dependent this algorithm is on the randomized starting points for each of the centroids. One way to solve this would be to run hundreds, if not thousands of trials and assess the results of each trial by some measurement to evaluate for the best fits. Depending on the size of the data, and the number of presumed k-clusters this procedure can prove to be costly and impractical in a lot of cases.\nIt is clear that we need some way to optimize this procedure that does not involve running many instances of the k-convergence algorithm and hoping for the best. To do so requires that we have an optimizer at our disposal and as it so happens there are already a number of \u0026ldquo;good\u0026rdquo; optimizer algorithms that have been worked out for us. We need only apply them to the problem at hand.\nIn the next post I will introduce the Adam optimizer and apply it to a much simpler problem before tackling this one. Thanks for reading, and until then!\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/machine-learning/",
	"title": "machine learning",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/python/",
	"title": "python",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/game/",
	"title": "game",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/games/",
	"title": "Games",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/games/ice-age/",
	"title": "Ice Age",
	"tags": ["javascript", "vue", "game"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Adventure throughout Azeroth and beyond following the events of the Frozen Throne, utilizing a real-time combat game system.\nPlay here\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/javascript/",
	"title": "javascript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/vue/",
	"title": "vue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/vue-js-game/",
	"title": "Vue.js Game",
	"tags": ["javascript", "vue", "game"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "So I built a game engine in javascript using Vue.js to do the rendering. It\u0026rsquo;s in an in-progress project, and therefore this post is as well.\nPlay here\n"
},
{
	"uri": "https://arcman7.github.io/en/notes/",
	"title": "Notes",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "I just made this blog. If there\u0026rsquo;s anything glaringly obvious that I\u0026rsquo;ve missed and need to or should fix please let me know in the comments below.\nAlso, Hugo is awesome, I used it to create this site.\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/asynchronous/",
	"title": "asynchronous",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/posts/javascript-squential-task-que/",
	"title": "Javascript: Sequential Task Queue",
	"tags": ["javascript", "promises", "asynchronous", "sequential order", "queue"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "I decided to write this post as the result of attempting to find a pattern for executing any number of asynchronous tasks in a specified order with javascript. It came as a surprise to me that this isn\u0026rsquo;t supported out of the box in any modern browers javascript engine.\nAfter googling around for a few minutes I came across this related blog post Decembersoft Inc. which comes close but doesn\u0026rsquo;t yield a working solution. I would reccomend checking it out as it was useful for me, and perhaps may hold some value for you as well. However, I will give you the gist of it here:\n Javascript allows you to chain promises in a serial fashion when the tasks are known beforehand and can be hard coded:   return task1.then(task2).then(task3);\n   This pattern does not allow you to programatically execute an unspecified number of asynchronous operations in a given order\n  Reduce to the rescue:\n   We\u0026rsquo;re going to use the Array.reduce() function to collapse the array of promises into a single promise chain.\n  // Serial return [ task1, task2, task3, ].reduce((promiseChain, currentTask) =\u0026gt; { // Note: promiseChain === initialPromise // on the first time through this function /* TODO */ }, initialPromise); (from the blog post)\n Which then leads to:   const reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(chainResults =\u0026gt; currentTask.then(currentResult =\u0026gt; [ ...chainResults, currentResult ] ) ); } const tasks = getTaskArray(); tasks.reduce(reducer, Promise.resolve([])); Okay cool, this is where you realize that it is their authors aim to collect the RESULTS of the promise chain in a sequential order, but not actually fire them off one after another. If you\u0026rsquo;re not sure or don\u0026rsquo;t believe me try this in your console:\n function getTasks() { const task1 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task1'); resolve() }, 2 * 1000); }); const task2 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task2'); resolve() }, 2 * 1000); }); const task3 = new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task3'); resolve() }, 2 * 1000); }); return [ task1, task2, task3, ] } var reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(currentTask); } var tasks = getTasks(); tasks.reduce(reducer, Promise.resolve()); All of these pending promises fire off at the same time as they\u0026rsquo;ve already been instantiated. Well shoot, back to square one. Just kidding, this pattern actually get\u0026rsquo;s us 90% of the way there. However, instead of having an array of already existing promises we want to use an array of functions that RETURN the promises we want to fire off. This looks like this:\nfunction getTasks() { const task1 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task1'); resolve() }, 2 * 1000); }); } const task2 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task2'); resolve() }, 2 * 1000); }); } const task3 = function() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { console.log('resolve task3'); resolve() }, 2 * 1000); }); } return [ task1, task2, task3, ] } var reducer = (promiseChain, currentTask) =\u0026gt; { return promiseChain.then(currentTask); } var tasks = getTasks(); tasks.reduce(reducer, Promise.resolve()); There, now you can can execute any arbitrary number of promises one after another. All you need to do in your code is collect an array of references to the functions that create/instantiate/return the promise that is the asynchronous operation you want to perform.\nEDIT: This pattern is not as unique as I initially thought. There are various implementations that already exist out there on the web, heres another one:\nhttps://github.com/BalassaMarton/sequential-task-queue\n"
},
{
	"uri": "https://arcman7.github.io/en/tags/promises/",
	"title": "promises",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/queue/",
	"title": "queue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/tags/sequential-order/",
	"title": "sequential order",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "The Author",
	"content": "The Author My name is Andrew Carpenter. I\u0026rsquo;m a fullstack engineer, living in San Francisco. I\u0026rsquo;ve been working in the bay area for the past four years with a focus on building clean UI\u0026rsquo;s for the end user.\nI recieved my bachelors degree in Physics at the University of Hawaii in 2013 and continued to do research on the mini Time Cube (mTC) experiment before switching to software.\n"
},
{
	"uri": "https://arcman7.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://arcman7.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]